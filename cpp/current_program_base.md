## 并发基础
### 一、顺序一致性
**_顺序一致性的陷阱_**  
C++ 程序表现得仿佛它们是按顺序执行的，完全遵守了 C++ 流程控制语句的控制。
仿佛给了编译器和计算机硬件的优化基础。
- 在底层编译器能够根据语句进行重排以改善程序性能。但是编译器明白
在测试一个变量或者是将其赋值给另一个对象之前，必须先确保它包含了所有最新计算结果。
- 现在多核处理器可能会选择乱序执行，但是它们包含了可以确保在随后读取同一个内存
地址之前，一定会先向该地址写入的逻辑。
- 甚至有些现代处理器的内存控制逻辑可能会选择延迟写入内存以优化内存总线的使用，但是
内存控制器知道哪次写值正在从执行单元通过高速缓存写会到主存中的过程中，而且
确保如果随后读取同一个地址时会使用上述过程中的值。

-------
并发会让情况变得复杂，在编译的时候不知道是否会有别的程序并发运行。编译器不知道哪个
变量会在线程间共享。当程序中包含共享数据的并发线程时，编译器对语句的重排和延迟写入
主存会导致计算结果和顺序执行语句的计算结果不同。  
开发人员必须向多线程程序中显式地加 入同步代码来确保可预测的行为的一致性。
当并发线程共享数据时，同步代码降低了并发量。

-------
由于仿佛的存在，顺序一致性只要遵循以下原则即可：  
当一条使用变量的语句被移动到相关语句之前或是之后时，只要不是将它移动 到更新该变量
的语句之后，程序就仍然具有顺序一致性；同样，在改变更新变量的语句的 执行顺序时，只要
不是将它移动到使用该变量的语句之后，程序就仍然具有顺序一致性。
-------

注意事项：  
在特定的编译器和硬件组合中，并非所有可能的加载和存储顺序的改变都会实际发生。（难以观测不代表不存在）
### 二、竞争
```C++

// 线程1运行于核心1上
shared_result_x = 1;
shared_flag_y = 1;
...
// 线程2运行于核心2上
while (shared_flag_y != 1)
/* 繁忙等待shared_flag_y被设置为1 */ ;
assert(shared_result_x == 1);
```
试想一下上述代码的情况：  
线程1上设置了 shared_result_x 和 shared_flag_y 的值，  
线程2上阻塞在 while 循环上确保 share_flag_y 被赋值为1。
由于编译器或者处理器改变了设置值的次序，导致shared_flag_y 退出循环的时候，
 shared_result_x 未被设置为1，触发程序异常。

只有那些在定义中不存在“看起来像是”这样含糊的字眼的编程语言，才能够确保在线程
之间被共享的变量的顺序一致性。其他编程语言支持这一点，因为共享变量是显式地被声明的；
编译器不会改变它们的位置，并会生成特别的代码来确保硬件也不会改变它们的位
置。并发的 C++ 程序必须显式地强制进行特定的交叉以保证顺序一致性。

### 三、同步
同步是多线程中语句交互的强制顺序。没有同步多线程间的执行难以预测，线程间的工作无法很好的协同。  
同步原语是一种编程结构，其目的是强制并发程序的交叉来实现同步。所有的同步
原语的工作原理都是让一个线程等待另一个线程或者挂起线程。通过强制执行特定的
执行顺序，从而避免竞争的发生。

同步只是一种概念上的存在，其实现方式不是固定的。经典的同步原语会与操作系统交互，切换线程
活动状态或者挂起状态。这种实现适合相对较慢处理器的计算器。通过操作系统的挂起会导致切换延迟明显。
如果计算机中多个执行流以真正的并发执行多个指令流，通过在共享变量上的忙等策略进行同步可以大幅度减少延迟。
设计人员也可以使用混合方式实现，先忙等若干时间，然后才进入切换。

### 四、原子性
如果没有线程能够在另一个线程对共享变量计算到一半的时候看到该变量被更新了，那么该共享变量
执行上述操作时具有原子性。
### 五、原子性操作的实现
- 1、互斥实现原子性

传统上，原子操作使用互斥实现。每一个线程在访问共享变量的时候必须获取一个互斥量，并且在完成操作
之后释放互斥量。确保同一个时间点只有一个线程可以访问此互斥量。

加载和存储共享变量必须同时只在一个线程可以访问的临街区中进行。正如前面所描述的，处理器和编译器
会移动加载和存储语句。有一种内存栅栏的机制可以防止共享变量的加载和存储系泄露到存储区之外。  
在处理器中，特殊的指令可以告诉处理器不要移动加载语句和存储语句穿越内存栅栏。在编译器中，内存栅栏
是概念上的，优化器不会跨越函数调用移动和加载语句，因为任何函数调用中都可能存在临界区。

位于临界区顶部的内存栅栏必须防止共享变量的加载被泄露至临界区之外。因此这个内存栅栏具有获取语义。
位于临界区底部的内存栅栏必须防止共享变量的存储被泄露至临界区之外，因此这个内存栅栏具有释放语义。

- 2、原子性硬件操作

通过互斥量实现的原子性会带来性能开销。

（1）临界区中消耗的时间越多，临界区从并发中夺取的时间越多，在共享变量上执行操作的线程越多，
临界区从并发中夺走的时间越多。（2）当多个线程在同一个临界区挂起或者等待的时候，无法保证哪一个线程一定
可以获取到资源。，可能会产生饥饿现象。（3）多个线程互相持有互斥量可能会产生死锁现象。

对于整数和指令这样的简单变量，在某些处理器上执行某些操作具有原子性，因为这样的操作由一条操作指令
执行，这些特殊的原子指令带有内存栅栏，确保执行过程中不会被打断。

原子操作仍然会序列化线程，哪怕这些操作只有一条指令？但是无锁程序可以将临界区的持续时间缩短一个数量级。

### 六、内存栅栏
https://sf-zhou.github.io/programming/memory_barrier.html
https://zhuanlan.zhihu.com/p/43526907

内存栅栏通过多个硬件线程的高速缓存来同步主内存。通常在一个线程与另一个线程同步时，这两个线程都会加上
内存栅栏。 C++ 11 之后的原子变量可以选择内存栅栏的级别。
- memory_order_acquire
- memory_order_release
- memory_order_acq_rel
- memory_order_consume
- memory_order_relaxed
### memory_order_acquire
可以理解为“通过其他线程完成所有的工作”，它确保随后的加载不会移动到当前的加载或者前面的加载之前。
它通过等待在处理器和主存之间的当前的存储操作完成来实现。如果没有内存栅栏，当一次存储还处于处理器和
主存之间时，另一个的线程在相同的内存地址，进行了一次加载，该线程会得到旧的数据，仿佛这次加载的操作
被移动到了操作之前。  
memory_order_acquire 可能会比默认的完全内存栅栏高效，比如在原子性读取繁忙等待 while 循环中的
标志位时。
### memory_order_release
可以理解为“通过这线程将所有工作释放到这个位置”的意思。它确保这个线程完成之前加载和存储操作不会被移动到
当前的存储之后。通过等待这个线程内部的当前存储操作完成来实现这一点的。

### memory_order_acq_rel
确保创建一个完全的内存栅栏。

### memory_order_consume
比 memory_order_acquire 弱一点的形式。它只要
求当前的加载发生在其他依赖这次加载数据的操作之前。
例如，当一个指针的加载被标 记为 memory_order_consume 时，紧接着的解引这个指针的操作就不会被移动它之前

### memory_order_relaxed
意味着允许所有的重排操作

内存栅栏会阻挡程序运行，直至所有的写操作都完成。在现实中，实际上只需等待所有写共享地址的操作完成
即可。但无论是 C++ 还是 x86 兼容处理器，都无法识别出这组更加小的地址范围，特别是当这组地址会随着线程不同而不同时。